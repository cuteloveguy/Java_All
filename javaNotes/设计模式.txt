设计模式


三大类：
1、创建型模式：单例Singleton模式、工厂模式、抽象工厂模式
2、结构型模式：适配器模式、桥接模式、装饰器模式
3、行为型模式（处理类对象之间通信交流）：包括观察者模式、策略模式、模板方法模式


提高代码可重用性质，提高工作效率



创建型模式：

1、单例模式

单例类只能有一个实例
单例类必须自己创建自己的实例
单例类必须给所有其他对象提供这一个实例

饿汉：
优点：无加锁机制，执行效率高
缺点：类加载就初始化，浪费内存


懒汉：
双重检验锁，保证线程安全和性能

静态内部类：
使用静态内部类，类加载时线程安全上锁且动态加载

枚举类：
保证线程安全和防止反射攻击

实现：转换枚举单例、新建枚举类



2、原型模式
复制现有对象来创建新对象，避免重复创建提高性能
通常实现 Cloneable 接口 重写 clone 方法


3、工厂模式
通过工厂实现对象创建，无需暴露对象创建逻辑，无需了解细节
缺点：种类过多会臃肿，难以维护

4、抽象工厂模式
定义一个创建对象的接口（抽象类），具体实现留给子类决定


5、建造者模式
一步一步进行创建不同类型对象。使用建造者类来封装对象创建过程并分解步骤







结构型模式：

1、适配器模式
允许不兼容的接口之间进行通信，将一个接口转换为客户端目标接口，不修改现有代码，重用现有类

类适配器：
缺点：只能适配单一类
class Adapter extends Adaptee implents Target{
	重写目标接口方法
}

对象适配器
原有类作为成员传递，不需要考虑兼容性

关键代码：
public class Adapter implements RoundHole {
    private SquarePeg squarePeg;
    
    public Adapter(SquarePeg squarePeg) {
        this.squarePeg = squarePeg;
    }
    
    @Override
    public double getRadius() {
        return squarePeg.getWidth() / Math.sqrt(2);
    }
}

2、组合模式 Composite Pattern
结构型设计模式，将对象组合成树状，包括叶节点和组合节点，组合节点可以存储叶节点


3、装饰器模式 Decorator Pattern

作用：
不修改代码情况下给现有类添加新功能
运行时动态向对象添加新功能		根据需求使用静态代理或者动态代理
不同方式组合对象实现不同功能

注意点：
装饰器类实现被装饰对象的相同接口以便对装饰器对象进行包装
装饰器类在调用被装饰对象方法之前或之后添加新的行为	之前添加参数验证 方法检查 之后处理返回值，执行日志操作
不要过多创建装饰器对象，会导致代码复杂

实际应用：
1）输入输出流 BufferReader 和 BufferWriter 对 FileReader 和 FileWriter 进行装饰，提供缓冲，加快读写效率

2）GUI 组件：动态添加新功能和样式，对按钮装饰，鼠标事件处理

3）日志记录器：添加额外元数据，时间戳，动态添加

4）权限控制

5）缓存系统

4、外观模式 Facade Pattern
对象型模式
创建外观类，提供简单接口来访问复杂系统中的子系统，客户端只需与外观类进行交互

比如电脑有硬盘CPU内存，用户只需要使用外观类就能操作他们


5、享元模式 Flyweight Pattern
共享对象来减少内存使用和对象创建开销，使用享元工厂管理共享对象，内部逻辑，外部逻辑在客户端

注意区分享元模式和原型模式：
原型模式是应用在创建开销较大的对象时候，如数据库连接池对象
享元模式是为了大量对象创建的快捷，如绘图，绘图的xy数据可以是外部对象

6、代理模式 Proxy Pattern

代理模式通过代理对象间接访问目标对象，在不改变原有目标对象基础上，增加额外拓展功能

1）静态代理
被代理对象与代理对象实现相同接口或者继承相同父类

优点：效率最高，代理类非常明确，无法做到通用











7、桥接模式
抽象化和实现化解耦，降低耦合度，使得系统更加灵活
Color 接口
Shape 抽象类，包含一个 Color 对象
定义 Color 具体实现类
定义 Shape 抽象类的具体实现类
创建对象对象实现方法
允许运行时动态改变 shape 类颜色，可以增加新的颜色形状而不改变现有的类




行为模式：
1、责任链模式
将请求沿着处理链进行传递，直到有一个处理程序处理它为止
步骤：
定义一个处理器接口，包含一个处理请求的方法
定义一个抽象处理器类，实现处理器借口，包含一个处理器接口实例，一个指向下一个处理器的引用方法，一个返回下一个处理器引用的方法
创建具体的处理器类，继承自抽象处理器类，实现处理请求方法
客户端代码中，创建处理器链，并将请求发送到链的第一个处理器


2、命令模式
允许将请求封装成对象，不同请求可以使用不同参数参数化
步骤：
命令接口
一个或多个具体命令类，在 execute 方法中实现实际的命令逻辑
调用者类，将具体命令和命令名称关联起来，需要时候调用 execute 方法

3、解释器模式
定义了一种语言和该语言的解释器，可以使用该语言表达特定操作，适用于编译器，表达式计算器

使用抽象语法树AST表示语言表达式，并使用解释器执行
实现：
抽象表达式：定义一个抽象解释器接口，包含解释器需要实现的方法
终结符表达式：实现抽象表达式的终结符，表示语言中的基本操作或值
非终结表达式：实现了抽象表达式接口的非终结符，用于表示语言中的复杂操作
上下文：包含了解释器需要的一些全局信息，例如变量、函数等
解释器：使用上述组件解释语言表达式，执行相应操作


4、迭代器模式
提供访问集合对象元素的方法，而不暴露对象内部表示，如数组，列表，树等
实现：
抽象迭代器接口、具体迭代器实现类，主函数

5、观察者模式
定义一对多依赖关系，一个对象状态发生改变，所有依赖他的对象都会得到通知并更新，建立了动态且松散耦合的关系场景
实现场景：事件处理，消息队列，GUI 编程

自行实现的步骤：
定义抽象主题接口，包括登记观察者，删除观察者，通知观察者
定义抽象观察者接口，包括更新状态方法，观察者名字
具体主题实现类实现抽象主题接口，设置属性方法并通知各观察者
具体观察者实现类实现抽象观察者接口，包括需要更改的各种属性，更新状态方法，展示输出方法等

java 自带观察者模式介绍
Observable 是一个抽象类，表示可观察对象，有添加、删除，通知观察者方法，当 Observable 对象发生改变会调用 notifyObservers 方法，通知观察者并更新
Observer 接口是观察者对象，具有更新状态方法，当 Observable 对象状态改变会调用 update 方法传递数据

实现：
具体主题类继承 Observable，并设置属性，setChanged() ，并调用 notifyObservers
具体观察者类实现 Observer 接口，并 update 更新，输出展示


6、状态模式
允许对象在内部状态改变时改变行为，状态封装成独立的类，请求委托给当前对象

注意：
状态模式可以增加类数量，需要考虑类的数量和复杂度
考虑状态的可拓展性和可延展性

实现：
定义状态接口，包括状态要实现的方法
定义具体状态类
定义上下文环境类 Context 包括状态对象，以及请求方法，请求方法中调用状态要实现的方法
客户端代码










